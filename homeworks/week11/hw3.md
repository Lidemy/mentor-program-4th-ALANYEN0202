## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫
  雜湊 : 明文 => 雜湊 => 雜湊完的亂碼 (無法回推)


  加密 : 明文 => 加密 => 加密完的亂碼 (可以回推)

  最大的差別就在於一個可以回推一個不能回推，舉例來說 :

  假如會員密碼都是 123

  123 => 雜湊 => asurn%21? (假設這是雜湊完的亂碼)


  123 => 加密 => effbiimw (假設這是加完密的亂碼)

  這時會員忘記密碼了，如果我們是用加密的，我們只要把 effbiimw 解密就可以知道會員原本的密碼了，因此我們知道 effbiimw 只能對應一組密碼 ( 123 )

  如果是雜湊的，我們只能請會員重新設定密碼，因為我們無法回推  asurn%21? 的字串，因為 asurn%21? 有可能是 123 或是其他的密碼，同個字串可能有相同的雜湊，這也是為什麼雜湊不可逆，因為雜湊的組合位數是固定的，但是密碼是無限的，所以一定會有重複的情形發生。

  因此最大的差別在於加密是一對一的，雜湊是一對多，就算被破解也很難得知正確的明文密碼，加密一被破解就跟裸奔沒兩樣了。

  為什麼密碼要雜湊過後才存入資料庫 ?
    
    首先是絕對不能存明文密碼，因為一被盜取，所有顧客資訊及被盜取，非常危險，再來為甚麼要雜湊，由上面回答可知雜湊不可逆，就算被破解也有好多組密碼不一定，當駭客嘗試多次登入時就可以把它阻擋，或是雜湊完再進行'加鹽' 的動作，也就是把雜湊完的亂碼前面再加一組亂碼，讓駭客更難破解，而加密由於是一組密碼對一組加密，所以一但破解也是跟明文一樣了。

## `include`、`require`、`include_once`、`require_once` 的差別
   `include`代表提取特定檔案，並載入所有內容。


  `include_once`一樣是提取檔案，差別在於如果有重複匯入，則會忽略，不會匯入兩次。

  使用  `include、include_once` 只會試圖匯入被請求匯入的檔案，即使該檔案沒有被找到，程式依舊會執行。

  當使用`require`代表絕對需要匯入該檔案，而`require_once`也一樣代表不會重複匯入。

  參考資料 [簡單談談PHP中的include、include_once、require以及require_once語句](https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/213553/)



## 請說明 SQL Injection 的攻擊原理以及防範方法
  原理就是利用填入資訊的地方(例如留言板的留言)，來填入 sql 的語法
讓資料庫產生錯誤解讀，例如 :
```php
$sql = sprintf("INSERT INTO ALAN_comments(nickname, content) values('%s', '%s')",$nickname, $content);
```
這是一段很正常的 sql 寫入的語法，我們把重點放在使用者填入的地方
```php
values('%s', '%s')",$nickname, $content);
```
可以得知第二欄是顧客留言的地方，假如顧客留:你好~我好帥 sql 會變成
```php
values('%s', '你好~我好帥')",$nickname, $content);
```
如果顧客改成留: `'),('我是假暱稱YA', '我是假留言YA` 這個奇怪的留言，那 sql 會變成
```php
values('%s', ''),('我是假暱稱YA', '我是假留言YA')",$nickname, $content);
```
有發現了嗎? 變成第一組留言是空白，但第二組的暱稱與內容竟然因為這樣也被寫入資料庫，變成可以自由竄改暱稱來留言，這就是 SQL Injection 的攻擊原理。

如何預防 :

其實很簡單，只要導入
```php
$sql = sprintf("INSERT INTO ALAN_comments(nickname, content) values(?, ?)"; //把 valuse裡的值改成 ?
$stmt = $conn->prepare($sql);
$stmt->bind_param('ss', $nickname, $content);//利用 bind_param('s為字串 i為數字，有幾個值就有幾個字母', $值一, $值二)
$result = $stmt->execute();
$result = $stmt->get_result();//有要拿資料就要導入 get_result()
```
其實原理有點不太懂，只知道他就是會把別人輸出的內容都當成字串。



##  請說明 XSS 的攻擊原理以及防範方法
  全名 Cross-site scripting (跨網站指令碼)，原理就是在網站上輸入別的標記語言使得網站讀取錯誤。

  例如在留言板輸入 `<h1>我是h1</h1>` 送出時會變成標題的  `我是h1` ，這樣是還好，如果輸入是 `<script>alert('我是彈出視窗YA~')</script>`送出時就會變成填出視窗，而如果在嚴重一點，可以使用script來做很多事情。

  解決方法:

  也是很簡單，只要導入跳脫字元的函式就可以，例如 php 提供的函式是`htmlspecialchars（$str)` 只要在每個輸出的地方導入就可以了。

這邊原理應該也是把輸出當成是字串，例如把 < 當成 `&lt;` 就會解讀為是 < 這個字串，而沒有特殊用途。


## 請說明 CSRF 的攻擊原理以及防範方法
  全名 Cross-site request forgery (跨站請求偽造)，原理就是攻擊者利用受害者的瀏覽器來發送請求，由於被請求的伺服器是信任該受害者的，因此放任通行，攻擊者藉此借取資料，或是拿取金錢。

  預防方法:

  其中一種就是做雙重驗證 Double Submit Cookie，由於攻擊者與被害者 domain 不同，server 端便在表單生一組隨機的 token ，同時 被害者端也生產同一組的 token，當被害者請求時，server便會檢查這兩組 token 是否一致，如果一致才會通過。

  不過現在很多瀏覽器也有提供方法給大家來防禦。

  詳情請參考 [老師好文:讓我們來談談CSRF](https://blog.techbridge.cc/2017/02/25/csrf-introduction/)